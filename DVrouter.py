####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json


class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.infty = 200
        self.rtable = {
            self.addr: {"cost": 0, "nhop": self.addr, "eport": None}
        }
        self.nport = {}
        self.nadd = {}
        pass

    def broadcast_dv(self):
        for neighbor_addr in self.nadd:
            dv = {}

            for dest, info in self.rtable.items():
                cost = info["cost"]
                nhop = info["nhop"]

                if dest != neighbor_addr and nhop == neighbor_addr:
                    dv[dest] = {
                        "cost": self.infty,
                        "nhop": nhop 
                    }
                else:
                    dv[dest] = {
                        "cost": cost,
                        "nhop": nhop 
                    }

            packet_content = json.dumps(dv)
        
            port = self.nadd[neighbor_addr]["eport"]
            packet = Packet(Packet.ROUTING, self.addr, neighbor_addr)
            packet.content = packet_content
            self.send(port, packet)

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.rtable:
                if self.rtable[packet.dst_addr]["cost"] < self.infty and self.rtable[packet.dst_addr]["eport"] != None:
                    self.send(self.rtable[packet.dst_addr]["eport"], packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            content = json.loads(packet.content)
            changed = False
            for dest, info in content.items():
                if info["cost"] == self.infty and dest in self.rtable and self.rtable[dest]["nhop"] == packet.src_addr:
                    self.rtable[dest].update({
                        "cost": self.infty,
                        "nhop": None,
                        "eport": None
                    })
                    changed = True
                    continue 

       
                if info["cost"] != self.infty:
                    neighbor_cost = self.nadd[packet.src_addr]["cost"]
                    new_cost = min(info["cost"] + neighbor_cost, self.infty)

                    if dest not in self.rtable or new_cost < self.rtable[dest]["cost"]:
                        self.rtable[dest] = {
                            "cost": new_cost,
                            "nhop": packet.src_addr,
                            "eport": self.nadd[packet.src_addr]["eport"]
                        }
                        changed = True

            if changed:
                self.broadcast_dv()

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        self.nport[port] = endpoint
        self.nadd[endpoint] = {
            "eport": port,
            "cost": cost
        }

        prev = self.rtable.get(endpoint)
        if prev is None or prev["cost"] != cost:
            self.rtable[endpoint] = {
                "cost": cost,
                "nhop": endpoint,
                "eport": port
            }
            self.broadcast_dv()
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        nadd = self.nport[port]
        del self.nport[port]
        del self.nadd[nadd]
        for entry in self.rtable:
            if self.rtable[entry]["eport"] == port:
                self.rtable[entry] = {
                    "cost": self.infty,
                    "nhop": None,
                    "eport": None
                }
        self.broadcast_dv()
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            self.broadcast_dv()
            pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"
